---
title: Dynamically Build Repository
order: 1
---

## Create New Project
The project must be multi-module

The module for APT processing needs to be a separate module because compilation has dependency relationships, so this is recommended.

Create two modules:
- repo-processor
- repo-test

Parent module
```xml

    <dependencyManagement>

        <dependencies>

            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-processor</artifactId>
                <version>2.0.14</version>
            </dependency>
            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-core</artifactId>
                <version>2.0.14</version>
            </dependency>
            <dependency>
                <groupId>com.easy-query</groupId>
                <artifactId>sql-api-proxy</artifactId>
                <version>2.0.14</version>
            </dependency>
            <!-- https://mvnrepository.com/artifact/org.springframework/org.springframework.context -->
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>5.3.4</version>
                <scope>provided</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

Where repo-test depends on repo-processor

repo-processor
```xml

    <dependencies>
        <dependency>
            <groupId>com.easy-query</groupId>
            <artifactId>sql-api-proxy</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
    </dependencies>

    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*</include>
                </includes>
                <excludes>
                    <exclude>
                        *.properties
                    </exclude>
                </excludes>
            </resource>
            <resource>
                <directory>target/generated-sources</directory>
            </resource>
        </resources>

        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <proc>none</proc>
                    <source>1.8</source>
                    <target>1.8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

## Create Custom Annotation
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ProxyRepository {
}

```

## Create Custom Interface
```java
public interface CrudRepository<TProxy extends ProxyEntity<TProxy, T>, T extends ProxyEntityAvailable<T,TProxy>> {
    Class<T> tableClass();
    ApplicationContext getApplicationContext();//In case you need something else later, you can get it through this method
    EntityQueryable<TProxy, T> getQuery();//Get the current repository for querying
}
```

The interface we need to implement ultimately looks like this:

Write SysUserRepository
```java
@ProxyRepository
public interface SysUserRepository extends CrudRepository<SysUserEntityProxy, SysUserEntity> {

}

Implementation class:
```java

 @Component
public class SysUserRepositoryImpl implements SysUserRepository {
    private final ApplicationContext applicationContext;
    private final EasyEntityQuery easyEntityQuery;

    public SysUserRepositoryImpl(ApplicationContext applicationContext,EasyEntityQuery easyEntityQuery){
        this.applicationContext = applicationContext;
        this.easyEntityQuery = easyEntityQuery;
    }

    @Override
    public Class<SysUserEntity> tableClass() {
        return SysUserEntity.class;
    }

    @Override
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    @Override
    public EntityQueryable<SysUserEntityProxy, SysUserEntity> getQuery() {
        return easyEntityQuery.queryable(tableClass());
    }
}
```

Comparing this class with the template, it's almost the same. We just need to modify some parts to achieve it.

## Create Template

We create a template in the repo-processor module

```java

public class AptConstant {

    public static final String PROXY_TEMPLATE = "package @{package};\n" +
            "\n" +
            "@{imports}" +
            "\n" +
            "/**\n" +
            " * this file automatically generated by easy-query, don't modify it\n" +
            " * 当前文件是scf4j自动生成的请不要随意修改\n" +
            " *\n" +
            " * @author scf4j\n" +
            " */\n" +
            " @Component\n" +
            "public class @{classImplName} implements @{classInterfaceName} {\n" +
            "    private final ApplicationContext applicationContext;\n" +
            "    private final EasyEntityQuery easyEntityQuery;\n" +
            "\n" +
            "    public @{classImplName}(ApplicationContext applicationContext,EasyEntityQuery easyEntityQuery){\n" +
            "        this.applicationContext = applicationContext;\n" +
            "        this.easyEntityQuery = easyEntityQuery;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public Class<@{argClassName}> tableClass() {\n" +
            "        return @{argClassName}.class;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public ApplicationContext getApplicationContext() {\n" +
            "        return applicationContext;\n" +
            "    }\n" +
            "\n" +
            "    @Override\n" +
            "    public EntityQueryable<@{argClassProxyName}, @{argClassName}> getQuery() {\n" +
            "        return easyEntityQuery.queryable(tableClass());\n" +
            "    }\n" +
            "}";


}

```

The template is very simple. We just use placeholders for the parts we need to replace.

## Create APT Processor
```java

//Full path of supported annotations. Using methods to implement these ensures no warnings in higher Java versions
// @SupportedAnnotationTypes({"com.eq.apt.repo.processor.annotations.ProxyRepository"})
// @SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ProxyRepositoryProcessor extends AbstractProcessor {
    private Filer filer;
    private Elements elementUtils;
    private Types typeUtils;
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.filer = processingEnv.getFiler();
        this.elementUtils = processingEnv.getElementUtils();
        this.typeUtils = processingEnv.getTypeUtils();
    }
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> supportedAnnotationTypes = new HashSet<>();
        supportedAnnotationTypes.add(ProxyRepository.class.getCanonicalName());
        return supportedAnnotationTypes;
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        if (!roundEnv.processingOver()) {
            // todo: handle some business logic....
        }
        return false;
    }

}

```
We create a `META-INF` folder under resources, then create a `services` folder, and then create a file named `javax.annotation.processing.Processor`. Fill in the file with the full class name of `ProxyRepositoryProcessor`: `com.eq.apt.repo.processor.processor.ProxyRepositoryProcessor`

## Write Business Logic and Debug
To debug APT, just right-click on `debug compile` after `clean` and `compile` on the right side.

[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt


[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt


[demo](https://github.com/xuejmnet/repo-apt) https://github.com/xuejmnet/repo-apt



::: tip Note!!!
> Don't forget the files under resources and don't forget to mark them as `generate sources root`
:::

## Create User and Repository
```java

@Table("t_user")
@EntityProxy
public class User implements ProxyEntityAvailable<User , UserProxy> {
    private String id;
    private String name;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}



@ProxyRepository
public interface UserRepository extends CrudRepository<UserProxy, User> {
}

```

clean->build and you can see the generated files in the test directory

